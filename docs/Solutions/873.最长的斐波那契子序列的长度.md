## 题目分析
给定前两个数字，$a_1$ 和 $a_2$后，对应的斐波那契数列是已经确定的。只要顺着该数列看最多有几个数列中的值在数组
`A`中就能知道该数列的长度。

基本思路：
1. 外层循环$a_2$
2. 内层循环$a_1$
3. 以$a_1,a_2$为起始，计算斐波那契数列的下一个值，直到该值不出现在数组`A`中。

值得改进之处：
- 如果子序列长度大于 3，则该子序列的长度大于 3
  的连续子序列也会被找到。实际上可以跳到下一循环节约时间。

## Code
**基础版**
```python
def lenLongestFibSubseq(self, A):
    ans = 0
    d = {a: i for i, a in enumerate(A)}
    r = []
    for j in range(1, len(A)):
        for i in range(j):
            a, b, c = A[i], A[j], 0
            while a + b in d:
                c += 1
                a, b = b, a + b
            if c:
                ans = max(c + 2, ans)
    return ans
```

**改进版**  
理应不去寻找斐波那契子序列的连续子序列会节省时间，但建立记录的代价在这里似乎更大，以致基础版运行时间更短。
```python
def lenLongestFibSubseq(self, A):
    ans = 0
    d = {a: i for i, a in enumerate(A)}
    r = dict()
    for j in range(1, len(A)):
        for i in range(j):
            if A[j] not in r or A[i] not in r[A[j]]:
                a, b, c = A[i], A[j], 0
                while a + b in d:
                    c += 1
                    a, b = b, a + b
                    if b not in r:
                        r[b] = set([a])
                    else:
                        r[b].add(a)
                if c:
                    ans = max(c + 2, ans)
    return ans
```
